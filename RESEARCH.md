# Portfolio Project Research

## Project Overview

Building a professional portfolio site for **Mike ONeal** - an AI Augmented Software Engineer. A fucking mercenary who comes in, executes, documents, and leaves. 30+ years of building systems, not just software. Showcasing:
1. **ClaimHawk** - An autonomous dental RCM system (Vision-Language models, MoE architecture)
2. **Diffusion Development** - A methodology for AI-native software development
3. **The Abundance Cascade** - The thesis on why software is the first replicator

---

## About Mike ONeal

### The Tagline
**AI Augmented Software Engineer** — I don't hold titles or put time in. I get shit done.

### The Elevator Pitch
High school dropout in the late '90s because I wanted to build software, not sit in classrooms. Got hired by Intel before I turned 18. From BBS systems to MMORPGs to autonomous agents. C to Lisp to TypeScript. Was a 10x developer before AI improvements, 100x after. I don't just build software — I'm the guy who builds software that builds software.

### What I Do
- **Design, plan, engineer, test, deploy, and audit** any application you want built
- **Systems, Mobile, Web, Desktop, Cloud** — I can do it all and then some
- **Automate entire workforces** and replace human labor with digital labor
- **See around corners** — decompose problems, find the prior art, synthesize solutions before the "experts" publish them
- **Research synthesis** — I don't reinvent wheels, I find papers and projects that solved parts of the problem and build on that foundation
- **Manage digital employees** — but not human ones (sorry not sorry)

### Why No "Job"?
I work too fast for it to be worth my time at a typical job. No one can keep up with me. It makes the normal humans angry. The C-level types fucking love me.

### The Track Record
Contract mercenary for: **X.com, YouTube, PayPal, Intel, Twitter, Apple, Microsoft, Amazon** — and a hundred companies and startups you haven't heard of.

- I own patents (not in my name)
- I run multiple LLCs that do real business and make real revenue
- I sit on the board of 2 startups
- I will never be made a manager, even though I employ multiple people myself

### Languages (The Evolution)
```
C → Lisp → TypeScript (and everything between)
BASIC → C → C# → JavaScript → .NET → Lisp → Ruby → Python → TypeScript → Rust
```

### Technical Domains
- **DevOps & Security**
- **Machine Learning**: Deep networks, genetic algorithms, convolutions, transformers, ViTs, vision models, voice models
- **Agentic Development**: Design, workflow, autonomous bots
- **Full Stack (Actually Full)**: Hardware → Systems → Applications → Web → ML → Trading → Crypto

### The Bookshelf (All Consumed)
- Martin Fowler (Refactoring, Patterns of Enterprise Architecture)
- Uncle Bob (Clean Code, Clean Architecture, SOLID)
- John McCarthy (Lisp, AI foundations)
- SICP (Structure and Interpretation of Computer Programs)
- The Pragmatic Programmer series
- Sutton & Barto (Reinforcement Learning)

### Published Work
Wrote extensively for Wrox Press in the late '90s/early 2000s

### What Drives Me
Money is just a scorecard. I'm not inexpensive, but solving incredibly difficult problems and migrating the world from "the old way" into the "new age" is what matters. I'm on top of the steamroller that will flatten the unexpected.

I don't give a shit about prestige or credit or climbing any ladder. I'm always looking for high-level tasks to aim at like a guided, hypersonic missile.

---

## The Stack: How I Actually Work

### The Lab
Multiple machines — Windows, Mac, Linux — networked together, all running agentic software. This isn't a dev environment. It's an operation.

### The Fleet
- **Multiple Claude Pro Max licenses** running autonomous agents across hardware
- **Anthropic Opus 4.5** via Claude Code and the Anthropic SDK
- **Qwen models** for vision, computer use, workflow automation
- **Clawdbot** and **Open Code** for additional orchestration
- **Gemini** & **Nano Banana** for specific workloads
- **Perplexity** for research and synthesis
- **OpenAI o1/5.2** when needed

### The Foundation
- Unix mastery (not familiarity — mastery)
- Networking, tunneling, virtualization
- Home lab infrastructure that would make most shops jealous

### The Workflow
I sit in Discord with my agents. Kanban board and GitHub issues for planning, design, build, tracking, and reporting. About 60% code, 40% documentation/tools/framework. Which agents are loaded depends on what I'm working on.

### The Result
What used to take months now takes days. That's not hyperbole. That's the 100x.

### Ahead of the Curve
I was doing context engineering a year ago — before it had a name. I see around corners. By the time something becomes a "best practice," I've already moved on to what's next.

I can give example after example: a solution I came up with, verified, and adopted as my standard — then some field expert publishes it months later as "the new approach." I'm not following the zeitgeist. I'm ahead of it.

### How I Stay Ahead
It's not magic. It's methodology:
1. **Decompose the problem** into a problem space
2. **Find the prior art** — papers, projects, academic and business trial-and-error that have already solved portions of that space
3. **Synthesize and build** on that foundation instead of reinventing wheels
4. **Adopt early, verify fast** — by the time it's "mainstream," I've already battle-tested it

This is how I make incredible progress. I'm not smarter than everyone. I just don't waste time rediscovering what's already been discovered.

---

## Profile Information

| Field | Value |
|-------|-------|
| **Name** | Mike ONeal |
| **Title** | AI Augmented Software Engineer |
| **GitHub** | github.com/claimhawk |
| **Email** | hello@claimhawk.app |
| **Company** | Tylt LLC |
| **Experience** | Coding since the late '90s |
| **Level** | Sr Engineer / Architect |
| **Education** | High School dropout — wanted to build, not study |

---

## Featured Project: ClaimHawk

### What It Is
I built an autonomous agent that replicates human dental billers by interacting with legacy software (Open Dental, Dentrix, Vyne) via computer vision and LLMs. Key innovation: privacy-preserving synthetic data generation that eliminates HIPAA risks while enabling infinite scalability.

This is what I mean when I say I automate entire workforces. One agent, infinite scalability, zero PHI exposure.

### Technical Implementation

1. **Expert Adapter Pattern ("Mole" Architecture)**
   - Modular system — no monolithic "black box" bullshit
   - Context-aware routing with deterministic harness
   - Specialized LoRA adapters per screen type

2. **Synthetic Data Pipeline**
   - Custom annotation engine for workflow digitization
   - Generative forge creating infinite variations
   - Zero PHI exposure — fully synthetic training data
   - Qwen-VL tensor optimization

3. **Training Infrastructure**
   - LoRA fine-tuning on Qwen3-VL
   - Auto-tuning hyperparameters
   - Early stopping with checkpoint preservation
   - CI/CD for model deployment

4. **Evolution Path**
   - Supervised Learning → Reinforcement Learning
   - Self-correcting agent capabilities
   - Closed-loop learning system

This is what happens when you give a 100x developer the tools to build digital employees.

---

## Methodology: Diffusion Development

### The Core Premise

Everyone's still building software the old way — sequential phases or iterative sprints. Both are slow. Both are wrong for the AI-native era. **Diffusion Development** is what I actually use: start with noise (rough structure), then progressively refine everything concurrently until the final form emerges. Like how diffusion models generate images, but for entire systems.

### The Analogy to Diffusion Models

| Diffusion Models | Diffusion Development |
|------------------|----------------------|
| Start with pure noise | Start with rough scaffolding of entire system |
| Iteratively denoise | Iteratively refine all components |
| All pixels refined together | All layers refined together (code, architecture, PM) |
| Guided by target distribution | Guided by evaluation criteria |
| Final image emerges organically | Final system emerges organically |

### Key Principles

1. **Concurrent Holistic Development**
   - Build the entire system skeleton first (all layers, all components)
   - No "finish module A, then start module B"
   - Everything exists in rough form from the start

2. **Progressive Refinement**
   - Each pass increases fidelity across the entire system
   - Early passes: broad strokes, placeholder logic, interface contracts
   - Middle passes: implementation details, error handling, edge cases
   - Late passes: optimization, polish, documentation

3. **Unified Abstraction Levels**
   - Code level: Functions start as signatures → stubs → implementations → optimized
   - Project level: All features scaffolded → fleshed out → integrated → hardened
   - System level: All services mocked → implemented → connected → load-tested
   - PM level: All milestones outlined → detailed → tracked → delivered

4. **Evaluation-Driven Convergence**
   - Define "done" criteria (evals) upfront
   - Refinement continues until evals pass
   - Like diffusion stopping when loss threshold is met

5. **Organic Evolution**
   - System grows like an organism, not assembled like a machine
   - Dependencies emerge naturally as interfaces solidify
   - Architecture is discovered, not dictated

### Contrast with Existing Methodologies

| Methodology | Approach | Limitation |
|-------------|----------|------------|
| **Waterfall** | Sequential phases | Late integration, no feedback loops |
| **Agile/Scrum** | Iterative sprints on features | Still sequential within features, artificial time-boxes |
| **Kanban** | Continuous flow | No holistic view, WIP limits are arbitrary |
| **Diffusion** | Concurrent refinement of whole | Requires new mental model, tooling |

### Why This Matters for AI-Assisted Development

- AI agents can work on multiple rough implementations simultaneously
- Refinement passes align with AI's iterative prompting model
- Evaluation criteria give AI clear convergence targets
- Human oversight shifts from "approve each step" to "guide refinement direction"

### Visual Metaphor

```
Traditional (Sequential):
[████████] → [████████] → [████████] → [████████]
 Module A     Module B     Module C     Integration

Diffusion (Concurrent Refinement):
Pass 1: [░░░░] [░░░░] [░░░░] [░░░░]  ← Rough sketch everywhere
Pass 2: [▒▒▒▒] [▒▒▒▒] [▒▒▒▒] [▒▒▒▒]  ← More detail everywhere
Pass 3: [▓▓▓▓] [▓▓▓▓] [▓▓▓▓] [▓▓▓▓]  ← Refinement everywhere
Pass N: [████] [████] [████] [████]  ← Converged system
```

### Research Questions to Explore

1. How do you define "refinement passes" concretely?
2. What tooling enables concurrent development across abstraction levels?
3. How do evals propagate from system-level to code-level?
4. Can this be formalized mathematically (loss functions, gradient descent analogy)?
5. What does "noise schedule" look like for software?

---

## Thesis: The Abundance Cascade

### The Core Premise

I'm living proof of this: the first stage of true abundance is the **commoditization of software development**. It's happening right fucking now. Software is the first domino because:

1. It's pure information - infinitely replicable at zero marginal cost
2. AI can already write, test, and deploy code
3. The feedback loop is tight and measurable (tests pass/fail, metrics)
4. No atoms to move, no physical constraints

This creates a **Star Trek replicator for software** - and it's happening now.

### The Bifurcation: 100x Developers vs. Displacement

**Phase 1: The Great Bifurcation**

| Developer Tier | Outcome |
|----------------|---------|
| **100x Developers** | Leverage AI to multiply output by 100x. Orchestrators, not typists. |
| **Average Developers** | Cannot compete with AI-augmented 100x devs. Displaced. |
| **Junior Developers** | Entry path disrupted. New entry point unclear. |

The skill that matters: **Taste + Direction + Evaluation**
- Knowing *what* to build (product sense)
- Guiding AI toward correct solutions (prompting, architecture)
- Recognizing when it's right (code review, evals)

Typing code becomes as relevant as typing memos.

**Phase 2: The 100x Devs Move Up the Stack**

As AI becomes capable of doing what 100x devs do today:
- The best move to **meta-engineering**: designing the systems that design systems
- Then to **problem selection**: identifying what should exist
- Eventually to pure **intent specification**: "I want X" → X exists

```
Today:     Human writes code → Software
Tomorrow:  Human directs AI → AI writes code → Software
Future:    Human expresses intent → System creates → Software
End state: Human desires → Reality shifts
```

### The Cascade into Physical Reality

Software is just the beginning. The pattern replicates:

| Domain | Replicator Stage | Unlock |
|--------|------------------|--------|
| **Software** | NOW | AI writes code, tests, deploys |
| **Digital Media** | NOW | AI generates images, video, audio |
| **Chemical** | NEAR | AI designs molecules, synthesis paths |
| **Biological** | MEDIUM | AI designs proteins, organisms, therapies |
| **Physical** | FAR | Molecular assemblers, true replicators |

**Why this order?**
1. **Software**: Pure bits. Already here.
2. **Chemical**: Well-understood physics, combinatorial search space AI excels at
3. **Biological**: More complex but still information (DNA is code)
4. **Physical**: Requires breakthrough in molecular manufacturing

### The Economic Transformation

**Scarcity → Abundance Economics**

Traditional economics assumes scarcity. When the cost of production approaches zero:

- **Labor theory of value** collapses (no labor needed)
- **Capital allocation** shifts to problem selection, not production
- **Status games** move from wealth accumulation to... something else

**What remains scarce?**
- Physical resources (temporarily - until molecular assembly)
- Time and attention (human bottleneck)
- Taste and judgment (what *should* exist)
- Meaning and purpose (why bother?)

### The Star Trek Replicator Analogy

| Star Trek Replicator | Software Replicator (Now) |
|---------------------|---------------------------|
| "Tea, Earl Grey, Hot" | "Build me a CRM for dental practices" |
| Matter assembled from energy | Code assembled from tokens |
| Pattern stored in computer | Architecture patterns in training data |
| Anyone can create anything | Anyone can create software |
| Post-scarcity economy | Post-scarcity for digital goods |

**Key insight**: We're living through the replicator moment for information goods. Software developers are the first to experience post-scarcity in their domain.

### Why This Matters

This isn't abstract philosophy — it's my **operating thesis**:

1. **ClaimHawk**: I built this using AI-augmented development. One engineer, one codebase, infinite digital employees.
2. **My positioning**: I'm already up the stack. I'm not writing code for the sake of writing code. I'm selecting problems and orchestrating solutions.
3. **What I'm building next**: Tools that accelerate the cascade. The steamroller keeps rolling.

### Timeline Speculation

| Milestone | Timeframe |
|-----------|-----------|
| 100x developer becomes standard expectation | 2025-2026 |
| Median developer displacement begins | 2026-2028 |
| Software replicator (intent → working system) | 2028-2030 |
| Chemical synthesis AI disrupts pharma/materials | 2027-2032 |
| Biological design AI disrupts medicine/agriculture | 2030-2040 |
| Physical replicators (molecular assembly) | 2040-2060? |

*These are speculative and likely wrong in specifics, but the direction seems clear.*

### Research Questions

1. What new roles emerge as coding becomes commoditized?
2. How do we handle the transition period (mass displacement)?
3. What governance structures handle post-scarcity domains?
4. How does meaning/purpose evolve when creation is trivial?
5. What accelerates the cascade from software to physical?

---

## Technical Stack Decision

### Next.js 15 + React 19 Considerations

**The React 19 Issue:**
React 19 has a known issue with async component handling that affects many third-party libraries. The patch involves configuring `reactCompiler` in Next.js config or pinning React to 18.x.

**Recommended Approach:**
- Use Next.js 15.x with React 19
- Configure `next.config.ts` with `experimental.reactCompiler` settings if needed
- OR use `--legacy-peer-deps` during install and pin React 18.x
- Monitor compatibility with animation libraries (framer-motion, etc.)

### Full Stack

| Category | Technology | Rationale |
|----------|------------|-----------|
| Framework | Next.js 15 | App Router, Server Components, best DX |
| Styling | Tailwind CSS 4 | Latest features, better performance |
| UI Components | shadcn/ui | Accessible, customizable, follows CODE_QUALITY |
| Animations | Framer Motion | Professional polish, performant |
| 3D/Visuals | Three.js / React Three Fiber (optional) | Hero visual impact |
| Content | MDX | For project write-ups if needed |
| Type Safety | TypeScript (strict) | Per CODE_QUALITY.md requirements |
| Deployment | Vercel | Optimal for Next.js |

---

## Site Structure

### Pages

1. **Home (`/`)**
   - Hero: Mike ONeal, AI Augmented Software Engineer
   - Tagline: "I don't hold titles or put time in. I get shit done."
   - Track record logos
   - Featured work previews (ClaimHawk + Methodology)
   - CTA for C-levels

2. **About (`/about`)**
   - Full story: BBS systems to autonomous agents
   - Track record: Contract work, patents, LLCs, board seats
   - Why no job: Works too fast, C-levels love it
   - Technical domains and languages
   - What drives me

3. **Methodology (`/methodology`)**
   - Diffusion Development — how I actually build software
   - Why Agile/Waterfall are wrong for AI-native era
   - Core principles with visuals
   - Link to ClaimHawk as proof it works

4. **Thesis (`/thesis`)**
   - The Abundance Cascade — where this is all going
   - The 100x bifurcation
   - Moving up the stack
   - The cascade into physical reality

5. **Projects (`/projects`)**
   - ClaimHawk as flagship project
   - Other work (placeholder for now)

6. **Project Detail (`/projects/[slug]`)**
   - ClaimHawk deep dive
   - Architecture diagrams
   - Technical implementation
   - "This is what happens when you give a 100x developer the tools"

7. **Contact (`/contact`)**
   - For C-level types who want results
   - "I'm always looking for high-level tasks to aim at like a guided, hypersonic missile"

### Components Architecture

```
src/
├── app/
│   ├── page.tsx                 # Home
│   ├── about/page.tsx
│   ├── thesis/page.tsx          # Diffusion Development
│   ├── projects/
│   │   ├── page.tsx             # Projects list
│   │   └── [slug]/page.tsx      # Project detail
│   ├── contact/page.tsx
│   ├── layout.tsx
│   ├── globals.css
│   └── not-found.tsx
├── components/
│   ├── ui/                      # shadcn primitives
│   ├── layout/
│   │   ├── header.tsx
│   │   ├── footer.tsx
│   │   └── nav.tsx
│   ├── sections/
│   │   ├── hero.tsx
│   │   ├── about-preview.tsx
│   │   ├── featured-project.tsx
│   │   ├── featured-thesis.tsx
│   │   └── tech-stack.tsx
│   └── features/
│       ├── project-card.tsx
│       ├── architecture-diagram.tsx
│       ├── diffusion-visualizer.tsx   # Animated refinement demo
│       ├── methodology-comparison.tsx
│       ├── cascade-timeline.tsx       # Abundance cascade animation
│       ├── bifurcation-chart.tsx      # 100x dev vs displacement
│       ├── stack-ladder.tsx           # Moving up the stack
│       └── contact-form.tsx
├── lib/
│   ├── utils.ts
│   └── constants.ts
├── types/
│   └── index.ts
└── content/
    ├── profile.ts                    # Bio, track record, positioning
    ├── projects/
    │   └── claimhawk.ts
    ├── methodology/
    │   └── diffusion-development.ts
    └── thesis/
        └── abundance-cascade.ts
```

---

## Design Direction

### Aesthetic
- **Professional & Technical**: Clean, minimal, data-driven feel
- **Dark mode primary**: ML/tech audience preference
- **Accent color**: Electric blue or cyan (tech/AI aesthetic)
- **Typography**: Modern sans-serif (Inter, Geist)
- **Visual elements**:
  - Architecture diagrams (Mermaid or custom)
  - Code snippets with syntax highlighting
  - Subtle animations on scroll
  - Gradient accents

### Inspiration
- Linear.app design language
- Vercel's portfolio sites
- AI/ML company sites (OpenAI, Anthropic)

---

## Code Quality Integration

From CODE_QUALITY.md, we must enforce:

1. **TypeScript Strict Mode** - All strict flags enabled
2. **Immutability** - `readonly` by default, no mutations
3. **Functional Paradigms** - Pure functions, side effects at edges
4. **Complexity Limits** - Max 10 cyclomatic, 3 nesting levels
5. **Component Limits** - Max 5 hooks, 7 props per component
6. **File Organization** - Per Next.js patterns in section 8
7. **Error Handling** - Zod validation, Result types
8. **Pre-commit Pipeline** - Prettier, ESLint, TypeScript checks

### Tooling Setup Required

- ESLint with `@typescript-eslint/strict`
- Prettier with project config
- Husky + lint-staged for pre-commit
- TypeScript with strict tsconfig

---

## Implementation Notes

**Positioning**: AI Augmented Software Engineer — mercenary, operator, 100x developer
**Voice**: Direct, confident, no bullshit. Light profanity is authentic to the brand.
**Aesthetic**: Dark mode, technical, operator aesthetic — not corporate, not startup-bro

### Site Sections to Prioritize

1. **Hero**: The hook — AI Augmented Software Engineer, 100x, get shit done
2. **What I Do**: Design, plan, engineer, test, deploy, audit — Systems, Mobile, Web, Desktop, Cloud
3. **Track Record**: The logos, the patents, the LLCs, the board seats
4. **The Stack**: The fleet — home lab, multiple agents, the operation. "What used to take months now takes days."
5. **ClaimHawk**: The proof — one engineer building digital employees
6. **Methodology**: Diffusion Development — how I actually build
7. **Thesis**: The Abundance Cascade — where this is all going
8. **Contact**: For the C-level types who want results
